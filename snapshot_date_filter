#!/usr/bin/env python3
"""snapshot_date_filter

Reads a date sorted list of snapshots on stdin, writes the snapshots to keep
or remove to stdout. Removed snapshots are printed in reverse sorted order.

Usage:
  snapshot_date_filter (keep | remove) [-l | --keep-latest] -f <fmt> -r <reten>
  snapshot_date_filter (-h | --help | --version)

Options:
  -h, --help          Show this message
  --version           Show version
  -f <fmt>            Date format string
  -l, --keep-latest   Always keep latest snapshot
  -r <reten>          Retention specification (see example below and source code
                      for a list of valid intervals)

Example:
  This example lists all zfs snapshots for mypool/data1, determines which
  snapshots to remove by running this script, and destroys those snapshots:

  zfs list -r -t snapshot -H -o name mypool/data1 \\
      | snapshot_date_filter remove -f "mypool/data1@auto-%Y-%m-%d_%H.%M" -r "day 7 week 4 month 12 year 3" \\
      | xargs zfs destroy

"""
import sys
from datetime import datetime, timedelta
from docopt import docopt

reten_keywords = {
    "minute": 60,
    "5min": 300,
    "10min": 600,
    "15min": 900,
    "30min": 1800,
    "hour": 3600,
    "day": 3600*24,
    "week": 3600*24*7,
    "month": 3600*24*30,
    "year": 3600*24*365,
}

def gen_keepsnaps(snapdates, reten, now=datetime.utcnow()):
    keepages = {
        timedelta(seconds=i*seconds)
        for keyword, seconds in reten_keywords.items()
        for i in range(1, reten.get(keyword, 0)+1)
    }
    isnap = iter(snapdates)
    try:
        for age in sorted(keepages, reverse=True):
            while True:
                snap = next(isnap)
                if now - snap <= age:
                    yield snap
                    break
    except StopIteration:
        # no more snapshots; we're finished
        pass

def parse_reten_spec(reten_str):
    tokens = reten_str.split()
    if len(tokens)%2 != 0:
        sys.stderr.write("Even numbers of words in reten spec required!\n")
        sys.exit(1)

    result = {}
    for key, val in zip(*[iter(tokens)]*2):
        if key not in reten_keywords:
            sys.stderr.write(
                f"reten interval '{key}' unknown; "
                f"valid values: {','.join(reten_keywords)}\n"
            )
            sys.exit(1)
        try:
            amount = int(val)
            if amount < 1:
                raise ValueError
        except ValueError:
            sys.stderr.write(
                f"reten value '{val}' for interval '{key}' is invalid\n"
            )
            sys.exit(1)
        result[key] = amount
    if not result:
        sys.stdout.write(f"Error: empty reten spec!\n")
        sys.exit(1)
    return result

def parse_dates(snapnames, fmt):
    for snapname in snapnames:
        try:
            yield datetime.strptime(snapname, fmt)
        except ValueError:
            # ignore snapshots that don't match the date format
            pass

if __name__ == "__main__":
    args = docopt(__doc__, version='snapshot_date_filter 0.1')
    fmt = args["-f"]
    reten = parse_reten_spec(args["-r"])
    keep_latest = args["--keep-latest"]
    keep = args["keep"]

    input_snapnames = sys.stdin.read().split("\n")
    input_snapdates = sorted(list(parse_dates(input_snapnames, fmt)))
    keepsnaps = gen_keepsnaps(input_snapdates, reten)
    try:
        latest = set(keep_latest * [input_snapdates[-1]])
    except IndexError:
        # empty input; nothing to do
        sys.exit(0)

    if keep:
        output_snapdates = sorted(set(keepsnaps) | latest)
    else:
        output_snapdates = sorted(
            set(input_snapdates) - set(keepsnaps) - latest,
            reverse=True
        )

    for snapdate in output_snapdates:
        print(datetime.strftime(snapdate, fmt))
