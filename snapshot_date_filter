#!/usr/bin/env python3
"""snapshot_date_filter

Reads a list of snapshots on stdin, writes the snapshots to keep or remove
according to the given retention specification to stdout. Removed snapshots
are printed in reverse sorted order.

Usage:
  snapshot_date_filter (keep | remove) -f <fmt> -r <reten>
                       [-l | --keep-latest] [-y | --keep-younger]
  snapshot_date_filter (-h | --help | --version)

Options:
  -h, --help          Show this message
  --version           Show version
  -f <fmt>            Date format string (required)
  -r <reten>          Retention specification (see example below and source code
                      for a list of valid intervals) (required)
  -l, --keep-latest   Always keep latest snapshot
  -y, --keep-younger  Keep snapshots younger than the youngest snapshot
                      according to the retention specification

Example:
  This example lists all zfs snapshots for mypool/data1, determines which
  snapshots to remove by running this script, and destroys those snapshots:

  zfs list -r -t snapshot -H -o name mypool/data1 \\
      | snapshot_date_filter remove -f "mypool/data1@auto-%Y-%m-%d_%H.%M" -r "day 7 week 4 month 12 year 3" \\
      | xargs zfs destroy

"""
import sys
from collections import defaultdict
from datetime import datetime, timedelta
from docopt import docopt

reten_intervals = {
    "minute": 60,
    "5min": 300,
    "10min": 600,
    "15min": 900,
    "30min": 1800,
    "hour": 3600,
    "day": 3600*24,
    "week": 3600*24*7,
    "4week": 3600*24*7*4,
    "month": 3600*24*30,
    "year": 3600*24*365,
}


def error_exit(message):
    sys.stderr.write(f"Error: {message}\n")
    sys.exit(1)


def reten_ages(reten):
    return {
        timedelta(seconds=i*reten_intervals[interval])
        for interval, amount in reten.items()
        for i in range(1, amount+1)
    }


def gen_keepsnaps(snapdates, keepages, now=datetime.utcnow()):
    def preference(d):
        # Calculate a preference score for a date.
        # I like snapshots at the start of hours, days, etc.
        return sum([
            8 * (d.minute == 0),
            4 * (d.hour == 0),
            2 * (d.day == 1),
            1 * (d.month == 1)
        ])

    snapdates = list(snapdates)
    keepages = sorted(keepages)

    # Of the snapshots between each pair of consecutive keepages (if any),
    # yield the oldest snapshot with the highest score as calculated by the
    # preference() helper function
    for agemin, agemax in zip(keepages, keepages[1:]):
        candidates = defaultdict(list)
        for d in snapdates:
            if agemin <= now - d < agemax:
                candidates[preference(d)].append(d)
        if candidates:
            highest = max(candidates)
            # oldest (min) of candidates with highest preference score
            yield min(candidates[highest])


def parse_reten_spec(reten_str):
    tokens = iter(reten_str.split())
    result = {}
    while True:
        try:
            interval = next(tokens)
        except StopIteration:
            break
        try:
            val = next(tokens)
        except StopIteration:
            raise ValueError("even numbers of words in reten spec required")
        if interval not in reten_intervals:
            raise ValueError(
                f"reten interval '{interval}' unknown\n"
                f"Valid values: {', '.join(reten_intervals)}"
            )
        try:
            amount = int(val)
            if amount < 1:
                raise ValueError
        except ValueError:
            raise ValueError(
                f"reten value '{val}' for interval '{interval}' is invalid"
            )
        result[interval] = amount
    if not result:
        raise ValueError("empty reten spec")
    return result


def parse_dates(snapnames, fmt):
    for snapname in snapnames:
        try:
            yield datetime.strptime(snapname, fmt)
        except ValueError:
            # ignore snapshots that don't match the date format
            pass


def date_filter(
    keep, snapdates, reten, keep_latest, keep_younger,
    now=datetime.utcnow()
):
    snapdates = sorted(list(snapdates))
    keep_ages = reten_ages(reten)
    keepsnaps = set(gen_keepsnaps(snapdates, keep_ages, now=now))
    try:
        latest = {snapdates[-1]} if keep_latest else set()
    except IndexError:
        # empty input; nothing to do
        return []
    younger = {
        d for d in snapdates
        if now - d < min(keep_ages)
    } if keep_younger else set()

    if keep:
        return sorted(keepsnaps | latest | younger)
    else:
        return sorted(
            set(snapdates) - keepsnaps - latest - younger,
            reverse=True
        )


if __name__ == "__main__":
    args = docopt(__doc__, version='snapshot_date_filter 1.0')
    fmt = args["-f"]
    try:
        reten = parse_reten_spec(args["-r"])
    except ValueError as e:
        error_exit(e)
    keep_latest = args["--keep-latest"]
    keep_younger = args["--keep-younger"]
    keep = args["keep"]
    input_snapnames = sys.stdin.read().split("\n")

    input_snapdates = parse_dates(input_snapnames, fmt)
    output_snapdates = date_filter(
        keep, input_snapdates, reten, keep_latest, keep_younger
    )

    for snapdate in output_snapdates:
        print(datetime.strftime(snapdate, fmt))
