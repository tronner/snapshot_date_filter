#!/usr/bin/env python3
"""snapshot_date_filter

Reads a date sorted list of snapshots on stdin, writes the snapshots to keep
or remove to stdout. Removed snapshots are printed in reverse sorted order.

Usage:
  snapshot_date_filter (keep | remove) [-l | --keep-latest] -f <fmt> -r <reten>
  snapshot_date_filter (-h | --help | --version)

Options:
  -h, --help          Show this message
  --version           Show version
  -f <fmt>            Date format string
  -l, --keep-latest   Always keep latest snapshot
  -r <reten>          Retention specification (see example below and source code
                      for a list of valid intervals)

Example:
  This example lists all zfs snapshots for mypool/data1, determines which
  snapshots to remove by running this script, and destroys those snapshots:

  zfs list -r -t snapshot -H -o name mypool/data1 \\
      | snapshot_date_filter remove -f "mypool/data1@auto-%Y-%m-%d_%H.%M" -r "day 7 week 4 month 12 year 3" \\
      | xargs zfs destroy

"""
import sys
from datetime import datetime, timedelta
from docopt import docopt

reten_intervals = {
    "minute": 60,
    "5min": 300,
    "10min": 600,
    "15min": 900,
    "30min": 1800,
    "hour": 3600,
    "day": 3600*24,
    "week": 3600*24*7,
    "month": 3600*24*30,
    "year": 3600*24*365,
}

def error_exit(message):
    sys.stderr.write(f"Error: {message}\n")
    sys.exit(1)

def gen_keepsnaps(snapdates, reten, now=datetime.utcnow()):
    keepages = {
        timedelta(seconds=i*reten_intervals[interval])
        for interval, amount in reten.items()
        for i in range(1, amount+1)
    }
    isnap = iter(snapdates)
    try:
        for age in sorted(keepages, reverse=True):
            while True:
                snap = next(isnap)
                if now - snap <= age:
                    yield snap
                    break
    except StopIteration:
        # no more snapshots; we're finished
        pass

def parse_reten_spec(reten_str):
    tokens = iter(reten_str.split())
    result = {}
    while True:
        try:
            interval = next(tokens)
        except StopIteration:
            break
        try:
            val = next(tokens)
        except StopIteration:
            raise ValueError("even numbers of words in reten spec required")
        if interval not in reten_intervals:
            raise ValueError(
                f"reten interval '{interval}' unknown\n"
                f"Valid values: {', '.join(reten_intervals)}"
            )
        try:
            amount = int(val)
            if amount < 1:
                raise ValueError
        except ValueError:
            raise ValueError(
                f"reten value '{val}' for interval '{interval}' is invalid"
            )
        result[interval] = amount
    if not result:
        raise ValueError("empty reten spec")
    return result

def parse_dates(snapnames, fmt):
    for snapname in snapnames:
        try:
            yield datetime.strptime(snapname, fmt)
        except ValueError:
            # ignore snapshots that don't match the date format
            pass

def date_filter(keep, input_snapdates, reten, keep_latest):
    keepsnaps = set(gen_keepsnaps(input_snapdates, reten))
    try:
        latest = set(keep_latest * [input_snapdates[-1]])
    except IndexError:
        # empty input; nothing to do
        return []

    if keep:
        return sorted(keepsnaps | latest)
    else:
        return sorted(set(input_snapdates) - keepsnaps - latest, reverse=True)

if __name__ == "__main__":
    args = docopt(__doc__, version='snapshot_date_filter 0.1')
    fmt = args["-f"]
    try:
        reten = parse_reten_spec(args["-r"])
    except ValueError as e:
        error_exit(e)
    keep_latest = args["--keep-latest"]
    keep = args["keep"]
    input_snapnames = sys.stdin.read().split("\n")

    input_snapdates = sorted(list(parse_dates(input_snapnames, fmt)))
    output_snapdates = date_filter(keep, input_snapdates, reten, keep_latest)

    for snapdate in output_snapdates:
        print(datetime.strftime(snapdate, fmt))
